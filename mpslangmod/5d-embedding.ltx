
\subsection{Language Embedding}
\label{embedding}


Language embedding enables \emph{heterogeneous} fragments with
\emph{independent} languages (\fig{langReuse}, but with a containment link
between $B5$ and $A3$). It is similar to reuse in that there are two independent
languages $l_1$ and $l_2$, but instead of establishing references
between two homogeneous fragments, we now embed instances of concepts from $l_2$
in a fragment $f$ expressed with $l_1$, so
\begin{align} 
\forall c \in \mathit{Cdn_f} \mid  \;
	&\mathit{lo(co(c.parent))} = l_1 \; \wedge \nonumber \\
	( &\mathit{lo(co(c.child))} = l_1 \vee \mathit{lo(co(c.child))} = l_2) )
\end{align}
Unlike language extension, where $l_2$ depends on $l_1$ because concepts in
$l_2$ extends concepts in $l_1$, there is no such dependency in this case. Both
languages are independent. We call $l_2$ the \emph{embedded} language and $l_1$
the \emph{host} language. Again, an adapter language $l_A$ that extends $l_1$
can be used to achieve this, where
\begin{align}
\exists c \in \mathit{Cdn_{l_A}} \mid \mathit{lo(c.parent)} = 
	l_A \wedge \mathit{lo(c.child)} = l_1
\end{align}

As an example we embed an existing, embeddable \ic{expressions} language into
the \ic{uispec} language. To do this, we \emph{do not} modify either the \ic{uispec}
language or the expression language, since, in case of embedding, none of them
may have a dependency on the other. Here is an example program using the
resulting language. Note the use of expressions behind the \ic{validate}
keyword:

\begin{code}
form CompanyStructure                                                                                                                                  
  uses Department                                                                                                                                      
  uses Employee                                                                                                                                        
                                                                                                                                                       
  field Name: textfield(30) -> Employee.name validate lengthOf(Employee.name) < 30                                                                     
  field Role: combobox(Boss, TeamMember) -> Employee.role                                                                                              
  field Freelancer: checkbox -> Employee.freelancer 
        validate if (isSet(Employee.worksAt)) Employee.freelancer == true else
                    Employee.freelancer == false 
  field Office: textfield(20) -> Department.description                                                                                                
\end{code}


\phead{Structure and Syntax} We create a new \ic{uispec\_validation} that
extends \ic{uispec} and it also extends \ic{expressions}. \fig{uival} shows the
structure. To be able to use the expressions, the user has to instantiate a
\ct{ValidatedField} instead of a \ct{Field}. \ct{ValidatedField} is also defined
in \ic{uispec\_validation} and is a subconcept of \ct{Field}.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.50]{figures/uival.png}
  \caption[labelInTOC]{The \ic{uispec\_validation} language defines a subtype of
  \ct{uispec.Field} that contains an \ct{Expression} from a reusable \ic{expressions}
  language. The language also defines a couple of additional expressions,
  specifically the \ct{AttributeRefExpr}, which can be used to refer to
  attributes of entities.}
  \label{uival}  
\end{center}
\end{figure}

To support the migration of existing models that use \ct{Field} instances, we
provide an intention. An intention (known as a quick fix in Eclipse) is an
in-place model transformation that can be triggered by the user by selecting
it from the intentions menu accessible via \ic{Alt-Enter}. This particular
intention is defined for a \ct{Field}, so the user can press \ic{Alt-Enter} on a
\ic{Field} and select \ic{Make Validated Field}. This transforms an existing
\ct{Field} into a \ct{ValidatedField}, so that validation expressions can be
entered. The core of the intention is the following script, which
performs the actual transformation:

\begin{code}
execute(editorContext, node)->void { 
    node<ValidatedField> vf = new node<ValidatedField>(); 
    vf.widget = node.widget; 
    vf.attribute = node.attribute; 
    vf.label = node.label; 
    node.replace with(vf); 
}
\end{code}


As mentioned, the \ic{uispec\_validation} language extends the \ic{uispec} and
\ic{expressions} languages. \ct{ValidatedField} has a property \ct{expr} that
contains the actual \ic{Expression}. As a consequence of polymorphism, we can
use any existing subconcept of \ct{Expression} defined in the \ic{expressions}
language here. So without doing anything else, we could write \ic{20 + 40 > 10},
since integer literals and the \ic{+} operator are defined as part of the
embedded \ic{expressions} language. However, to write anything useful, we have to be
able to reference entity attributes from within expressions. To achieve this, we create
the \ct{AttributeRefExpr} as shown in \fig{uival}. We also create
\ct{LengthOfExpr} and \ct{IsSetExpression} as further examples of how to adapt
an embedded language to its new context --- i.e. the \ic{uispec} and \ic{entities}
languages. The following is the structure definition of the \ic{LengthOfExpr}.

\begin{code}
concept LengthOfExpr extends Expression        
  properties:                                  
    alias = lengthOf                                    
  children:                                     
    Expression  expr  1 
\end{code}                                               

Note how it defines an \ic{alias}. The \ic{alias} is used to pick the concept
from the code completion menu. If the user is in expression context, he must
type the \ic{alias} of a concept to pick it from the code completion menu.
Typically, the alias is selected to match the leading keyword of the concept's
projection. The \ct{LengthOfExpr} is projected as \ic{lengthOf(something)}, so
by choosing the alias to also be \ic{lengthOf}, the concept can be entered
naturally.


The \ct{AttributeRefExpr} references entity attributes. However, it may only
reference those attributes of those entities that are used in the form within
which we define the validation expression. The following is the code for the
search scope:

\begin{code}
(model, scope, referenceNode, linkTarget, enclosingNode)
                             ->join(ISearchScope | sequence<node< >>) { 
  nlist<Attribute> res = new nlist<Attribute>; 
  node<Form> form = enclosingNode.ancestor<concept = Form, +>; 
  for (node<EntityReference> er : form.usedEntities) { 
    res.addAll(er.entity.attributes); 
  } 
  res; 
}
\end{code}

Notice that the actual syntactic embedding of the expressions in the
\ic{uispec\_validation} language is not a problem because of how projectional editors
work. No ambiguities may arise. We simply define \ct{Expression} to be a child
of the \ct{ValidatedField}.


\phead{Type System} The general challenge here is that primitive types such as
\ct{int} and \ct{string} are defined in the \ic{entities} language and in the
reusable expression language. Although they have the same names, they are not
the same types. The two sets of types must be mapped. Here are a couple of
examples. The type of the \ct{IsSetExpression} is by definition
\ct{expressions.BooleanType}. The type of the \ct{LengthOf}, which takes an
\ct{AttrRefExpression} as its argument, is \ct{expressions.IntType}.
The type of an attribute reference is the type of the attribute's \ct{type} property, as in
\ic{typeof(are) :==: typeof(are.attr.type);}. However, consider now the
following code:

\begin{code}
  field Freelancer: checkbox -> Employee.freelancer 
        validate if (isSet(Employee.worksAt)) Employee.freelancer == true else
                    Employee.freelancer == false 
\end{code}

This code states that if the \ct{worksAt} attribute of an employee is set, then
its \ct{freelancer} attribute must be \ct{true} else it must be \ct{false}. It
uses the equals operator from the expressions language. However, that operator
expects two \ct{expressions.BooleanType} arguments, but the type of the
\ct{Employee.freelancer} is \ct{entities.BooleanType}. In effect, we have to
override the typing rules for the expressions language's equals operator. Here
is how we do it, using \ct{Equals} as an example.

In the expressions language, we define overloaded operation rules. We specify
the resulting type for an \ct{EqualsExpression} depending on its argument types.
Below is the code in the expressions language that defines the resulting type to
be \ct{boolean} if the two arguments are \ct{Equallable}:

\begin{code}
operation concepts: EqualsExpression                                                     
  left operand type: new node<Equallable>() 
  right operand type: new node<Equallable>() 
operation type:                                                                          
  (operation, leftOperandType, rightOperandType)->node< > { 
    <boolean>; 
  }               
\end{code}

In addition to this code, we have to specify that \ct{expressions.BooleanType}
is a subtype of \ct{Equallable}, so this rule applies if we use equals with two 
\ct{expressions.BooleanType} arguments. We have to tie this overloaded operation
specification into a regular type inference rule.

\begin{code}
rule typeof_BinaryExpression {                                                                                                                                                                                                                                                                                                                                                                                                                                                   
  applicable for concept = BinaryExpression as binaryExpression                                                                                                                                                                                                                                                                                                                                                                                                                  
  overrides false                                                                                                                                                                                                                                                                                                                                                                                                                                                                
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 
  do {                                                                                                                                                                                                                                                                                                                                                                                                                                                                           
    when concrete (typeof(binaryExpression.left) as left) { 
      when concrete (typeof(binaryExpression.right) as right) { 
        node<> opType = operation type( binaryExpression , left , right ); 
          if (opType != null) { 
            typeof(binaryExpression) :==: opType; 
          } else { 
            error "operator " + binaryExpression.concept.name + 
                  " cannot be applied to these operand types " + 
                  left.concept.name + "/" + right.concept.name 
               -> binaryExpression; } 
}  }  }  } 
\end{code}

To override these typing rules to work with \ct{entities.BooleanType}, we simply
provider another overloaded operation specification in the \ic{uispec\_validation}
language:

\begin{code}
operation concepts: EqualsExpression                                       
  one operand type: <boolean> // this is the entities.BooleanType!     
operation type:                                                            
  (operation, leftOperandType, rightOperandType)->node< > { 
    <boolean>;  // this is the expressions.BooleanType 
  } 
\end{code}


\phead{Generator} The generator has to create BaseLanguage code, which is then
subsequently transformed into Java text. To deal with the transformation of the
expressions language, we can do one of two things:

% > - create own text gen (just like it's done for BaseLanguage
% > constructions). This way of generating code looks more straight
% > forward then "wrapping expressions into some kind of
% > TextHolderStatement".
% > - reduce expressions to a BaseLanguage constructions (the second
% > choice proposed in paper).
% >
% > I think TextHolderStatement can be mentioned here as an option, but
% > MPS textgen looks like a native way to produce textual output from the
% > model.


\begin{itemize}
  \item We can use the expression's language existing to-text generator
  and wrap the expressions in some kind of \ct{TextHolderStatement}. Remember
  that we cannot simply embed text in BaseLanguage, since that would not work
  structurally. A wrapper is necessary.
  \item Alternatively, we can write a (reusable) transformation from expressions
  code to BaseLanguage code; these rules would be used as part of the
  transformation of \ic{uispec} and \ic{uispec\_validation} code to BaseLanguage.
\end{itemize}

Since many DSLs will map code to BaseLangauge, it is worth the effort to
write a reusable generator from \ic{uispec\_validation} expressions to BaseLanguage
expressions. We choose this second alternative. The generated Java code is
multi-sourced, since it is generated by two independent code generators.


Expression constructs from the reusable expr language and those of BaseLanguage
are almost identical, so this generator is trivial. We create a new language
project \ic{de.voelter.mps.expressions.blgen} and add reduction rules.
\fig{expr2blgen} shows some of these reduction rules.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.50]{figures/expr2blgen.png}
  \caption[labelInTOC]{A number of reduction rules that map the reusable
  expression language to BaseLanguage (Java). Since the languages are very
  similar, the mapping is trivial. For example, a \ct{PlusExpression} is mapped
  to a \ic{+} in Java, the left and right arguments are reduced recursively through
  the \ic{COPY\_SRC} macro.}
  \label{expr2blgen}  
\end{center}
\end{figure} 

In addition to these, we also need reduction rules for those new expressions
that we have added specifically in the \ic{uispec\_validation} language
(\ct{AttrRefExpression, isSetExpression, LengthOf}). Those are defined in
\ic{uispec\_validation}. As an example, \fig{reductionAttributeRef} shows the rule
for handling the \ct{AttrRefExpression}. The validation code itself is
"injected" into the UI form via the same placeholder reduction as in the case of
the \ic{rbac\_entities} language.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.50]{figures/reductionAttributeRef.png}
  \caption[labelInTOC]{References to entity attributes are mapped to a call to
  their getter method. The template fragment (inside the \ic{<TF .. TF>}) uses
  two reference macros (->\$) to "rewire" the reference to the Java bean instance, and
  the dummy \ct{toString} method call to a call to the getter.}
  \label{reductionAttributeRef}  
\end{center}
\end{figure}
 
 
Just as in the discussion on extension \todoref{}, we may want to use
constrains to restrict the embedded language in the context of a
validation rule. Imagine we wouldn't embed a small, reusable expression
language, but the expressions part of C. It defines all kinds of operators
relating to pointers, bit shifting and other C-specific things that are not
relevant in the validation of UI fields. In this case we may want to use a
\ic{can be ancestor} constraint to restrict the use of those operators in the
validation expressions.


As a consequence of MPS' projectional editor, no ambiguities may arise if
multiple independent languages are embedded. Let us consider the potential cases
for ambiguity:

\begin{description}
  \item[Same Concpet Name:] Embedded languages may define concepts with the same
  name as the host language. This will not lead to ambiguity because concepts
  have a unqiue ID  as well. A program element will use this ID to refer to the
  concept whose instance it represents.
  \item[Same Concrete Syntax:] The projected representation of a concept is not
  relevant to the functioning of the editor. The program would still be
  unambiguous to MPS even if \emph{all elements had the same notation}. Of
  course it would be confusing to the users.
  \item[Same Alias:] If two concepts that are valid at the same location use the
  same alias, then, as the user types the alias, it is not clear which of the
  two concepts should be instantiated. This problem is solved by MPS opening the
  code completion window and requiring the user to explicitly select which
  alternative to choose. Once the user has made the decision, the unique ID is
  used to create an unambiguous program tree. 
\end{description}






\section{Introduction}
\label{intro}

\subsection{Approach and Structure of the paper}

\todo{align terminology with other papers}

Language modularization, extension and composition (LME\&C) is an important
ingredient to the efficient use of DSLs, just like reuse in general is important
to software development. We discuss the need for LME\&C in the context of DSL
design in \cite{VoelterVisserDimensions2011}, where we also introduce some of the
terminology used in this paper. Traditionally, LME\&C, including the respective
IDEs, has been hard for various reasons, including limited composability of
grammars, non-modular IDEs as well as semantic interactions. Specifically,
LME\&C requires the following concerns to be considered:


\begin{itemize}
  \item The concrete and the abstract syntax have to be combined. Depending on
  the kind of composition, this requires the embedding of one syntax into
  another one. This, in turn, requires modular grammars.
  \item The static semantics (i.e., the constraints and the type system) have to
  be integrated. For example, in the case of language extension, new types have
  to be "made valid" for existing operators.
  \item The execution semantics have to be combined as well. In practice, this
  may mean mixing the code generated from the composed languages, or composing
  the generators.
  \item Finally, the IDE that provides code completion, syntax coloring, static
  checks and other relevant services has to be extended and composed.
\end{itemize}

With JetBrains MPS two of these challenges --- composability of concrete syntax
and modular IDEs --- are a completely solved problem, as this paper will show.
Modular type systems are reasonably well-supported. Semantic interactions are
hard to solve in general, but can be handled reasonably in many relevant cases,
as we show in this paper. However, as we will see, in many cases
languages have to be designed \emph{explicitly for reuse} in order to make them
reusable. After-the-fact reuse, without considering it during the design of the
reusable language, is possible only in limited cases. However, this is true for
reuse in software generally.

The paper is structured as follows. In \sect{typesOfMod} we outline the various
kinds of LME\&C as defined and explained in \cite{VoelterVisserDimensions2011}.
Then, we describe how projectional editors work in general, and how MPS works
specifically (\sect{HowMPSWorks}). Next, we provide a brief overview of
related tools and approaches to illustrate how MPS is different (\sect{Related}). Then we develop
the core language which acts as the basis for the extension and composition
examples. We use the simplest possible language (one that supports the
definition of data entities) for this task.
This section (\sect{entitiesLanguage}) also serves as a very brief tutorial on
language definition in MPS. The main part of the paper, the implementation of
the various extension and composition approaches, is discussed in
\sect{extAndComp}. Finally, \sect{Eval} discusses what works well and at what
could be improved in MPS with regards to extension and composition.


\subsection{Additional Resources}

The example code developed for this tutorial can be found at github.com and
works with MPS 2.0:

\vspace{5pt}
\ic{https://github.com/markusvoelter/MPS-Language-Composition-Demos---For-MPS-2.0}
\vspace{5pt}

A set of recorded demos (90 minutes in total) that walk through all the example
code is available on Youtube. The initial video is here: 

\vspace{5pt}
\ic{http://www.youtube.com/watch?v=lNMRMZk8KBE}. 
\vspace{5pt}

\noindent The others are either suggested by Youtube, or you can find them by
searching for \emph{Language Modularization and Composition with MPS (Part X)}, where X is
between 1 and 8.

Note that this paper is not a complete MPS tutorial. MPS is very deep and
powerful, so we have to focus on those aspects that are essential for LME\&C. We
refer to the LWC 11 MPS tutorial for details:

\vspace{5pt}
\ic{http://code.google.com/p/mps-lwc11/wiki/GettingStarted}


\subsection{Types of Modularization}
\label{typesOfMod}


As we describe in the paper on DSL design dimensions
\cite{VoelterVisserDimensions2011}, we distinguish language \emph{combination}, \emph{extension}, \emph{reuse} and
\emph{embedding}.


\phead{Extension} A language B extends another language A if B contains
additional language concepts. This means that for programs written in B, all
concepts from A are available, plus those defined in B. Concepts in B may
specialize concepts in A. This means that in B programs, the specialized concept
can be used wherever A programs expect only the more general one, effectively
adapting the Liskov substitution principle to language concepts. An extended
language may also restrict the base language, so certain concepts are not
available in the sublanguage.


\phead{Combination} If a domain is structured along different concerns, and
these concerns should be implemented using separate viewpoints, then it is often
useful to implement every concern as a separate DSL. When these DSL are
developed from scratch, as a group, then dependencies between the concerns can
be materialized as dependencies between the languages and the language concepts.
A language B may depend on language A because a concept in language B references
a concept in language A. The models remain separate, only cross-references
connect the two.
 
\phead{Reuse} Reuse describes the case where a language has been developed
explicitly to be used in contexts not known at the time of development of that
language (this is in contrast to combination). So the language cannot have
dependencies to other languages. To make it fit in with a new context, the
reusable language has to be extended so it can reference concepts from languages
in that context.


\phead{Embedding} Embedding is a special case of reuse, where the reused
language is syntactically embedded into languages from the context. If the host
language is designed with an awareness of the composed language, the host
language can simply depend on the composed language and embed concepts from it.
As in the case of language reuse, the composed language may have to be extended
to "plug it into the context". If both the host language and the composed
language have been designed independent of each other and should be combined
later, then both the host language and the composed language will have to be
extended.

\vspace{8pt}
In this paper we illustrate all of these approaches with MPS. At the center is a
simple \ic{entities} language. We then build an additional language to illustrate
LME\&C. \fig{languagestructure} illustrates these additional languages. The
\ic{uispec} language illustrates \emph{combination} with \ic{entities}. \ic{relmapping} is an
example of \emph{reuse} with separated generated code. \ic{rbac} illustrates
reuse with intermixed generated code. \ic{uispec\_validation} demonstrates
\emph{extension} (of the \ic{uispec} language) and \emph{embedding} with regards to
the expressions language.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.4]{figures/languagestructure.png}
  \caption[labelInTOC]{\ic{entities} is the central language. \ic{uispec} defines UI
  forms for the \ic{entities}. \ic{uispec\_validation} adds validation rules, and composes
  a reusable expressions language. relmapping provides a reusable database
  mapping language, \ic{relmapping\_entities} adapts it to the \ic{entities} language.
  rbac is a reusable language for specifying permissions; \ic{rbac\_entities} adapts
  this language to the \ic{entities} language. }
  \label{languagestructure}  
\end{center}
\end{figure}

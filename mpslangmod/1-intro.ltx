

\section{Introduction}
\label{intro}

\subsection{Approach and Structure of the paper}

Language modularization, extension and composition (LME\&C) is an important
ingredient to the efficient use of DSLs, just like reuse in general is important
to software development. We discuss the need for LME\&C in the context of DSL
design in \cite{VoelterVisserDimensions2011}, where we also introduce some of the
terminology used in this paper. Traditionally, LME\&C, including the respective
IDEs, has been hard for various reasons, including limited composability of
grammars, non-modular IDEs as well as semantic interactions. Specifically,
LME\&C, requires the following concerns to be considered:


\begin{itemize}
  \item The concrete and the abstract syntax have to be combined. Depending on
  the kind of composition, this requires the embedding of one syntax into
  another one. This, in turn, requires modular grammars.
  \item The static semantics, i.e. the constraints and the type system have to
  be integrated. For example in case of language extension, new types have to be
  "made valid" for existing operators.
  \item The execution semantics have to be combined as well. In practice, this
  may mean mixing the code generated from the composed languages, or composing
  the generators.
  \item Finally, the IDE that provides code completion, syntax coloring, static
  checks and other relevant services has to be extended and composed as well.
\end{itemize}

With JetBrains MPS two of these challenges --- composability of concrete syntax
and modular IDEs --- are a completely solved problem, as this paper will show.
Modular type systems are reasonably well supported. Semantic interactions are
hard to solve in general, but can be handled reasonably in many relevant cases,
as we show in this paper as well. However, as we will see, in many cases,
languages have to be designed \emph{explicitly for reuse}, in order to make them
reusable. After-the-fact reuse, without considering it during the design of the
reusable language, is possible only in limited cases. However, this is true for
reuse in software generally.

The paper is structured as follows. In \sect{typesOfMod} we outline the various
kinds of LME\&C as defined and explained in the \cite{VoelterVisserDimensions2011} paper.
Then we describe how projectional editors work in general, and how MPS works specifically
(\sect{HowMPSWorks}). Next we provide a brief overview over related tools and
approaches to illustrate how MPS is different (\sect{Related}). Then we develop
the core language which acts as the basis for the extension and composition
examples. We use the simplest possible language, entities, for this task. This
section (\sect{entitiesLanguage}) also serves as a very brief tutorial on
language definition in MPS. The main part of the paper, the implementation of
the various extension and composition approaches is discussed in
\sect{extAndComp}. Finally, \sect{Eval} looks at what works well and at what
could be improved in MPS with regards to extension and composition.


\subsection{Additional Resources}

The example code developed for this tutorial can be found at github.com:

\vspace{5pt}
\verb#https://github.com/markusvoelter/MPS-Language-Composition-Demos---For-MPS-2.0#
\vspace{5pt}

\noindent It is developed with MPS 2.0 M6 and should run with the final version
of MPS 2.0 as well. At the point of this writing, MPS 2.0 had not yet been released and
hence I couldn't test it.

A set of recorded demos (90 minutes in total) that walk through all the example
code is available on Youtube. The initial video is here: 

\vspace{5pt}
\verb#http://www.youtube.com/watch?v=lNMRMZk8KBE#. 
\vspace{5pt}

\noindent The others are either suggested by Youtube, or you can find them by
searching for \emph{Language Modularization and Composition with MPS (Part X)}, where X is
between 1 and 8.

Note that this paper cannot be a complete MPS tutorial. MPS is very deep and
powerful, so we have to focus on those aspects that are essential for LME\&C. We
refer to the LWC 11 MPS tutorial for a at detailed MPS tutorial:

\vspace{5pt}
\verb+http://code.google.com/p/mps-lwc11/wiki/GettingStarted+


\subsection{Types of Modularization}
\label{typesOfMod}


As we describe in the paper on DSL design dimensions
\cite{VoelterVisserDimensions2011}, we distinguish language \emph{combination}, \emph{extension}, \emph{reuse} and
\emph{embedding}.


\phead{Extension} A language B extends another language A if B contains
additional language concepts. This means that for programs written in B, all
concepts from A are available, plus those defined in B. Concepts in B may
specialize concepts in A. This means that in B programs, the specialized concept
can be used wherever A programs expect only the more general one, effectively
adapting the Liskov substitution principle to language concepts. An extended
language may also restrict the base language, so certain concepts are not
available in the sublanguge.


\phead{Combination} If a domain is structured along different concerns, and
these concerns should be implemented using separate viewpoints, then it is often
useful to implement every concern as a separate DSL. When these DSL are
developed from scratch, as a group, then dependencies between the concerns can
be materialized as dependencies between the languages and the language concepts.
A language B may depend on language A because a concept in language B references
a concept in language A. The models remain separate, only cross-references
connect the two.
 
\phead{Reuse} Reuse describes the case where a language has been developed
explicitly to be used in contexts not known at the time of development of that
language (this is in contrast to combination). So the language cannot have
dependencies to other languages. To make it fit in with a new context, the
reusable language has to be extended so it can reference concepts from languages
in that context.


\phead{Embedding} Embedding is a special case of reuse, where the reused
language is syntactically embedded into languages from the context. If the host
language is designed with an awareness of the composed language, the host
language can simply depend on the composed language and embed concepts from it.
As in the case of language reuse, the composed language may have to be extended
to "plug it into the context". If both the host language and the composed
language have been designed independent of each other and should be combined
later, then both the host language and the composed language will have to be
extended.

\vspace{8pt}
In this paper we illustrate all of these approaches with MPS. At the center is a
simple entities language. We then build additional language to illustrate
LME\&C. \fig{languagestructure} illustrates these additional languages. The
uispec language illustrates \emph{combination} with entities. relmapping is an
example of \emph{reuse} with separated generated code. \emph{rbac} illustrates
reuse with intermixed generated code. uispec\_validation demonstrates
\emph{extension} (of the uispec language) and \emph{embedding} with regards to
the expressions language.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.4]{figures/languagestructure.png}
  \caption[labelInTOC]{entities is the central language. uispec defines UI
  forms for the entities. uispec\_validation adds validation rules, and composes
  a reusable expressions language. relmapping provides a reusable database
  mapping language, relmapping\_entities adapts it to the entities language.
  rbac is a reusable language for specifying permissions; rbac\_entities adapts
  this language to the entities language. }
  \label{languagestructure}  
\end{center}
\end{figure}

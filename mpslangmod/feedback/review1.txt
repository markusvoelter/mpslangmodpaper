----------------------- REVIEW 1 ---------------------
PAPER: 2
TITLE: Language and IDE Modularization, Extension and Composition with MPS
AUTHORS: Markus Voelter

The paper discusses various language compositions using the MPS tool. Building languages, general-purpose and 
domain-specific, by composing them is a hard problem, which is not yet fully achieved since one needs to take 
composition of syntactic and semantic parts into account as well as integrated development environment (IDE) 
used for constructing programs in newly developed languages. Such IDE usually consists of editor, debugger, 
test engine, etc. In this respect the paper can be important contribution. However, this is no so since different 
types of composition at conceptual level are not well defined and explained. The other major shortcoming of this 
paper is author’s limited knowledge of related work already done in this area.

-> I have rewritten intro and related work. 

- I don’t like the title of this paper too much. Is not “extension” treated as just one kind of “composition”? 
  Moreover, the paper doesn’t deal with IDE modularization. Moreover, it is not clear to me, what is a relation 
  between “composition” mentioned in the title and “combination” mentioned in Section 1.3? Anyway, the whole paper 
  is fuzzy and so it is the title.
  
-> I have changed the title to "Language and IDE Modularization and Composition with MPS". 
  This way, none of the four techniques is specifically mentioned in the title.

-> The paper does deal with IDE modularization. Each language module comes with its own
   "piece of IDE", and after language composition, the IDE provides support for the 
   composed languages.

- The paper is about language modularization, extension and composition. But, author didn’t provide clear definitions of these terms. Moreover, the paper is full of vague and imprecise statements. For example, page 2: “The concrete and the abstract syntax have to be combined”. It is unclear to me what author’s intention is here. Either, a language is designed starting with abstract or concrete syntax (after domain analysis where commonalities and variabilities are discovered) and a mapping from abstract syntax to concrete syntax is needed or vice verse. While combining concrete and abstract syntax I don’t think some meaningful artifact can be obtained. Is this abstract and concrete syntax combining needed when developing a single language or in language composition?

- Combining languages means to achieve correct combination on syntax and semantic level. Semantic level can be further divided in static and dynamic semantics. But, author’s view is very limited since only type system is discussed on static semantic level, and only code generation is discussed on dynamic semantic level (e.g., “mixing the code generated from the composed languages”). This limitation should be clearly visible and explicitly mentioned.

- Similarly, combining IDE is only discussed for editors (code completion, syntax coloring). But, not for other indispensable language-based tools like debugger, test engine, profile etc.

- The author wrote on page 2: “With JetBrains MPS two of these challenges - composability of concrete syntax and modular IDEs - are a completely solved problem”. Since language composability is not well defined in this paper it is hard to see if above claim is really true. Language composition has many forms and is hard to see if all of them are supported by MPS. On the other hand, IDE is not just an editor. I don’t think debugging is already solved for different forms of language composition.

- Section 1.3 discusses about type of modularization. Title is misleading again since only language modularization is discussed. More importantly, I don’t think these are only types of language modularization. It is much closer to types of language composition. Even in the last case I don’t think that all types were covered (e.g., combination of mentioned approaches or reusing just a part of a language - piggyback). Since author didn’t define language modularization and composition this section is very fishy. Different types, extension, combination, reuse and embedding, are not well explained and many unanswered questions appear. Is not “embedding” just a special case of “extension”? But, in the paper it is mentioned that “embedding is just a special case of “reuse”. Or, in the case of combination it is written that “A language B may depend on language A because a concept in language B references a concept in language A”. Is this not true also for “e
xtension”? Yet another example, “reuse” is defined as “Reuse describes the case where a language has been developed explicitly to be used in contexts not known at the time of development of that language (this is in contrast to combination)” and “embedding” as “If the host language is designed with an awareness of the composed language …”. In other words, “reuse” requires context non-awareness, while “embedding” context awareness. How “embedding” then can be a special case of “reuse”? On page 6 author starts talking about “language assimilation” which is not mentioned as a type of language modularity (composition). Hence, the obvious question remain unanswered is to which category “assimilation” is classified.  All these concepts are imprecisely defined and very vague. But, this section is crucial for the rest of the paper! Moreover, the structure of this section is not in line with introductory statement: “we distinguish languag!
 e combination, extension, reuse and embedding”. Descriptions in this section should be in the same order.

- The author should cite relevant work when particular concept, tool or system is mentioned. For example, I’m missing citation when Misra C, Lego mindstorms, Osek operating system are referred in the text. And there are many other examples.

- Related work section is very weak. Seems that author are not aware of many similar systems (e.g., AbleJ, Cedalion, JastAdd, LISA, Modular denotational semantics, Polyglot, Tattoo, ...) where language composition on semantic level is possible. In many cases, only language composition on syntactic level is discussed (e.g., “By using scannerless parsers it is possible to combine different languages, ...”), or it is mentioned that language combination in Xtext is easily possible. But, it is not clear if only on syntactic level or on semantic level, too. It is mentioned on page 33: “The challenge of grammar composition is not an issue in MPS at all, since no grammars and parsers are used”. But, language composition is not just grammar composition! Semantics is much more important. Description of systems which enable composition of languages on semantic level is very weak. For example, author should compare their work with

MERNIK, Marjan, ZUMER, Viljem. Incremental programming language development. Comput. syst. struct., 2005, Vol. 31, pp. 1-16


- In all examples Language’s semantics is described with Java code. Hence, the meaning of language constructs is described with generated code and only translational semantics can be used. This limitation should be clearly emphasized in the paper.

- Most of figures are too small and hard to read. Moreover, is this paper, if accepted, be printed in color? If not, some statements (e.g., “Expression blocks (in blue) are basically ...” will be odd.

- In Section 5.1 language combination is discussed. What if in both combined languages two concepts have the same name? That means that in both languages there is a same “non-terminal” which doesn’t represent the same concept. Seems that author assumed that by combining languages the same name means the same concept (non-terminal). Such an assumption may or may not be valid.

- I don’t understand the following statement on page 18: “(the type of /verb+yield 1;+ would be int)”. Please rephrase.

- On page 23 the author wrote: “Assuming this would work in MPS, this would be the most elegant solution. But it does not”. Please include explanation why it is not working.

- It is not clear from description on page 24 how generator priorities can be set.

- On page 33 the author wrote: “The concrete syntax for elements of the base language cannot be overridden in the sublanguage, although this is supposed to change”. However, this feature was supported by LISA more than 10 years ago.

- On page 34 the author wrote: “In essence, the suggested approach is a bit like object orientation (components == classes, facets == methods), with a rich advise framework (as in AOP)”. But, this approach was exactly already taken in LISA where languages act as classes. The lexical, syntax and semantics parts act as methods which can be overridden or inherited.

MERNIK, Marjan, LENIC, Mitja, AVDICAUSEVIC, Enis, ZUMER, Viljem. Multiple attribute grammar inheritance. Informatica, 2000, vol. 24, no. 2, pp. 319-328.

Aspect-oriented extension of LISA has been described in:

REBERNAK, Damijan, MERNIK, Marjan, HENRIQUES, Pedro Rangel, DA CRUZ, Daniela, VARANDO PEREIRA, Maria João. Specifying Languages Using Aspect-oriented Approach: AspectLISA. CIT. J. Comput. Inf. Technol., 2006, vol. 14, no. 4, pp. 343-350

REBERNAK, Damijan, MERNIK, Marjan, WU, Hui, GRAY, Jeffrey G. Domain-specific aspect languages for modularising crosscutting concerns in grammars. IET softw., Jun. 2009, vol. 3, iss. 3, pp. 184-200.

- Reference section is very weak and many related papers are omitted. Moreover, in many cases publisher/conference/TechnicalReport/WebPage and/or pages are simple omitted (e.g., [3, 9, 10, 11]).


Typos:
=======

-> they have all been fixed.


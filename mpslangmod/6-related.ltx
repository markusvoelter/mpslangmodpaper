
\section{Related Work}
\label{Related}

\subsection{Contemporary Tools}

\todo{For all of those tools discuss syntax, type sys and semantics. And maybe
remove one or two of them since I'll add all the other related work below? }

\todo{comapre to parser-based stuff in general}

MPS is not the only projectional workbench and projectional workbenches are not
the only approach to language modularity and composition. For example, the
Intentional Domain Workbench (IDW) \cite{SimonyiCC06} is another projectional
editor that has been used in real projects. An impressive presentation about its
capabilities can be found in an InfoQ presentation titled "Domain Expert DSL"
(\ic{http://bit.ly/10BsWa}). IDW is conceptually very similar to MPS, although
quite different in many details. We will not provide more details here, partly
because Intentional Software is very sensitive about publishing information
about details of their technology.


MetaEdit+ (\ic{http://metacase.com}) is an example of a purely graphical
language workbench (tables and forms can also be used). Languages are defined
via meta models, constraints, code generators and graphical symbols associated
with the meta-model. Language concepts can be represented by different symbols
in different diagrams types and elements from several languages can be used in
one diagram. Elements from language A can reference elements in language B. This
is not surprising since graphical language workbenches are (and have always
been) projectional. Since this paper focuses mostly on textual language, we
include MetaEdit+ here only for completeness.


Eclipse Xtext (\ic{http://eclipse.org/Xtext}) supports the creation of
extremely powerful text editors (with code completion, error checking and syntax
coloring) from an enhanced EBNF-like grammar definition. It also generates a
meta-model that represents the abstract syntax of the grammar as well as a
parser that parses sentences of the language and builds an instance of the
meta-model. Since it uses Eclipse EMF as the basis for its meta models, it can
be used together with any EMF-based model transformation and code generation
tool (examples include Xpand, ATL, and Acceleo, all at
\ic{http://eclipse.org/modeling}). Language referencing is easily possible;
Code completion for references into other models as well as cross-model and
cross-language consistency checks in the editor are supported natively.
Language reuse, extension and embedding are quite limited, though. It is
possible to make a language extend one other language. Concepts from the base
language can be used in the sub language and it is possible to redefine grammar
rules defined in the base language. Creating new subtypes (in terms of the
meta-model) of language elements in the base language is also possible. However,
it is not possible to define different representations of the same element
(except the concrete syntax of the reference) and it is not possible to embed
arbitrary languages or language modules. This is mainly because the underlying
parser technology is antlr (\ic{http://antlr.org}) which is a classical two
phase LL(*) parser which has problems  with grammar composition
\cite{BravenboerV08}. While single inheritance is useful, and many interesting
DSLs can be built with Xtext, single inheritance language extension is not
enough in practice; it would be like object-oriented programming with only
inheritance and no delegation or traits.



SDF \cite{HeeringHKR89} (\ic{http://strategoxt.org/Sdf}), developed by the
University of Delft, uses scannerless parsers. Consequently, languages can be
embedded within each other. Code generators are implemented via term rewriting
on the abstract syntax, but rendered in the concrete syntax. Currently, SDF is
mainly a set of command-line tools, but IDE support (with automatically
generated eclipse editors) is in progress as part of Spoofax \cite{KatsV10}
\linebreak(\ic{http://strategoxt.org/Spoofax}).
\todo{Add some more detail, in particular the escape cahraceters in
composition.}



Monticore (\ic{http://monticore.org}) is another parser-based
language engineering environment that generates parsers, meta-models, and editors based on extended grammar.
Currently, the group at RWTH Aachen university works on modularizing languages
\cite{KrahnRV10}.
Languages can extend each other and can be embedded within each other. An important idea is
the ability to not regenerate the parsers or any of the related tools
after a combined language has been defined. 


FURCAS (\ic{http://www.furcas.org/}) is a tool that is developed by
SAP and FZI Karlsruhe. FURCAS stores models in an abstract structure. However, for editing it "projects" the model
into plain ASCII. So when editing the model, users actually edit ASCII text.
Consequently, syntax definition also includes a definition of indentation and
white space conventions, otherwise the projection could not work. Second, a lot
of effort has to be put into retaining object identity \cite{Goldschmidt08}.
If an abstract structure is projected into text, and then something is moved around
and saved back into the abstract structure, it has to be made sure the objects
(identified by UUIDs) are not deleted and recreated, but really just moved. This
is important to make sure that references between models which are based on the
UUIDs and not (qualified) names remain valid. By using scannerless parsers it
is possible to combine different languages, however a combined grammar has to be
defined and the parser has to be regenerated to be able to use the composed
language. As a consequence of the projectional approach, it is possible to
define several syntaxes for the same abstract structure or define views and subsets for
a model. FURCAS also generates IDE-like editors (based on Eclipse).

Note that while parser-based approach are becoming more flexible (as illustrated
by some of the tools mentioned in this section), they will not be able to
work with non-parseable code, inlined tables, diagrams or annotations. 

For a general overview of language workbenches, please refer to the Language
Workbench Competition at \ic{http://languageworkbenches.net}. Participating
tools have to implement a standardized language and document the implementation
strategy. This serves as a good tutorial of the tool and makes them comparable. 
As of June 2012, the site contains 15 submissions.

\subsection{Other Related Work}

\todo{(e.g., AbleJ, Cedalion, JastAdd, LISA, Modular denotational semantics, 
  Polyglot, Tattoo, ...) }

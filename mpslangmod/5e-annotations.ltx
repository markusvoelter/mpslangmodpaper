
\subsection{Language Annotations}

\todo{following par was hard to follow, please reword}
\todo{Do we generally need more detail?}
\phead{Structure and Syntax} Since in a projectional editor the visual
representation of a program is not necessarily the complete information in the
program, and since the program's persistence format is not the concrete
syntax, it is possible to store additional data in a program, and show it
optionally. The mechanism MPS uses for this is called annotations.
Using this approach, we can store the mapping from entity attributes to database
columns directly in the entity, resulting in the following code:


\begin{code}
module company                                 
  entity Employee {                            
    id : int -> People.id                      
    name : string -> People.name               
    role : string -> People.role               
    worksAt : Department -> People.departmentID        
    freelancer : boolean -> People.isFreelancer
  }                                            
                                            
  entity Department {                          
    id : int -> Departments.id                 
    description : string -> Departments.descr  
  }                                            
\end{code}

This is a heterogeneous fragment, consisting of code from the \ic{entities}, as well
as the annotations. From a concrete syntax perspective, the column mapping is
"embedded" in the entity description. In the underlying persistent data
structure, the information is also actually stored in the entity model. However,
the definition of the \ic{entities} language does not know that this additional
information is stored and projected "inside" entities! No modification to the
\ic{entities} language is necessary whatsoever. Instead, we define an additional
language relmapping\_annotations which extends the \ic{entities} language as well as
the relmapping language. In this language we define a annotation link:


\begin{code}
annotation link declaration colMapping
    stereotype node                   
    cardinality 1                     
    source Attribute                  
    target AttrToColMapping           
\end{code}

This must be read as follows: we create an annotation for \ct{Attribute} which
can point to one instance of \ct{AttrToColMapping}. \ct{AttrToColMapping} is
simply another concept that has one reference that points to a \ct{Column}:

\begin{code}
concept AttrToColMapping extends BaseConcept implements <none>  
  references:                               
    Column column 1 specializes: <none>       
\end{code}                                            

Structurally, an annotation is a child of the node it annotates. So the
\ct{Attribute} has a new child of type \ct{AttrToColMapping}, and the reference
that contains the child is called \ct{@colMapping}. However, in the editor the
relationship is reversed. The editor for \ct{AttrToColMapping} wraps the editor
for \ct{Attribute}, as \fig{annotationeditor} shows. The annotation is added via
an intention ("quick fix" via Alt-Enter).


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.55]{figures/annotationeditor.png}
  \caption[labelInTOC]{The editor for the \ct{AttrToColMapping} embeds the
  editor of the concept it is annotated to (using the \ct{attributed node}
  cell). It then projects the reference to the referenced column. This way the
  editor of the annotation has control of if and how the editor annotated
  element is projected.}
  \label{annotationeditor}  
\end{center}
\end{figure}

\todo{Did I remove the stupid special or in the formulas?}

Note that it is also possible to define the annotation source to be
\ct{BaseConcept}, which means the annotation can be attached to any node. The
language that contains the annotation then has no dependency to any other
language. This is useful for generic "metadata" such as documentation,
requirements traces or presence conditions in product line engineering. We have
described this in \cite{VoelterVisser2011} and \cite{Voelter2010}.

\phead{Type System} The same typing rules are necessary as in the
\ic{relmapping\_entities} language described previously. They reside in
relmapping\_annotations.

\phead{Generator} The generator is also broadly similar to the previous example
with \ic{relmapping\_entities}. It takes the \ic{entities} model as the input, and then
uses the column mappings in the annotations to create the entity-to-database
mapping code.

\vspace{10pt}
The annotations introduced earlier were typed to be specific to certain target
concepts (\ct{EntityAttribute} in this case). A particularly interesting use 
of annotations includes those that can be annotated to \emph{any} language
concept (formally targeting \ct{BaseConcept}). In this case, there is no
dependency between the language that contains the annotation and the language
that is annotated. This is very useful for "meta data", as well as anything that
can be processed generically. 

An example of the first case is traceability links (\fig{requirementstrace}).
This annotation can be annotated to any language concept and adds pointers
(trace links) to requirements. As a consequence of the projectional approach,
the program can be shown with or without the annotations, controlled by a global
switch.

\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.50]{figures/requirementstrace.png}
  \caption[labelInTOC]{Requirements traces can be annotated to any arbitrary
  program elements (the annotation is defined to target \ct{BaseConcept}).
  Consequently, the language that defines the annotation has no dependency on
  any of the languages whose concepts it can annotate.}
  \label{requirementstrace} 
\end{center}
\end{figure}

An example of the second case is product line variability annotations
(\fig{featuredependencies}). Boolean expressions over configuration switches can
be annotated to any model element. Such an annotation means that the respective
element is only in the program variant, if the Boolean expression is true for
the given setting of configuration switches. The generic transformation simply
removes all elements whose annotation evaluates to false. The expressions can
also be evaluated as part of the projection, showing the code for a given
variant. The code is of course still editable. Details on this approach can be
found in \cite{Voelter2010} and \cite{VoelterVisser2011}.

\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.50]{figures/featuredependencies.png}
  \caption[labelInTOC]{Feature dependency annotations are Boolean expresssions
  over configuration switches that determine whether the annotated program
  element is part of a program variant. The transformation removes all those
  elements for which the annotation evaluates to \ic{false}.}
  \label{featuredependencies}  
\end{center}
\end{figure}

\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.50]{figures/featureCutDown.png}
  \caption[labelInTOC]{The variant customization of program code cannot just
  be performed during code generation, but also in the editor. The figure
  shows the state machine from \fig{featuredependencies}, customized to the 
  variant where only the \emph{bumper} switch is turned on. The \emph{bumper}-specific 
  parts are highlighted.}
  \label{featureCutDown}  
\end{center}
\end{figure}
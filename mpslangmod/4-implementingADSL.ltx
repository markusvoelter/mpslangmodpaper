
\vspace{-3mm}
\section{Implementing a DSL with MPS}
\label{entitiesLanguage}
\vspace{-1mm}

This section illustrates the definition of a language with JetBrains MPS. Like
other language workbenches, MPS comes with a set of DSLs for language
definition, a separate DSL for each language aspect such as structure, editor,
type systems, generators as well as things like quick fixes or refactorings. MPS
is bootstrapped, so these DSLs are built with MPS itself.


We illustrate language definition with MPS based on a simple \ic{entities}
language (some example code is shown below). \emph{Modules} are root nodes they
live as top-level elements in \emph{models}. According to the terminology
introduced in \sect{terminology} root nodes (and their descendants) are
considered \emph{fragments}.


\begin{code}
module company                       // continued...
  entity Employee {                  entity Department {  
    id : int                           id : int      
    name : string                      description : string
    role : string                    } 
    worksAt : Department
    freelancer : boolean
  }                     
\end{code}





\vspace{-2mm}
\phead{Structure and Syntax} Language definition starts with the AS, called
\emph{structure} in MPS. \fig{entities} shows a UML diagram of the \ic{entities}
language AS. The following code shows the definition of the \ic{Entity}
concept\footnote{In addition to \ic{properties}, \ic{children} and
\ic{references}, concept definition can have more characteristics such as
\ic{concept properties} or \ic{concepts links}. However, these are not needed
for this example, so we don't show them here. The code above shows all the
characteristics used in this example}. \ic{Entity} extends \ic{BaseConcept}, the
root concept, similar to \ic{java.lang.Object} in Java. It implements the
\ic{INamedConcept} interface to inherit a \ic{name} field. It declares a list of
children of type \ic{Attribute} in the \ic{attributes} role.
A concept may also have references to other concepts (as opposed to children).


\vspace{-2mm}
\begin{code}
concept Entity extends BaseConcept implements INamedConcept        
  is root: true
  children:                                     
    Attribute attributes 0..n
\end{code}                                               

\begin{figure}[h]
\begin{center}
  \includegraphics[scale=0.7]{figures/entities2.png}
  \caption[labelInTOC]{The abstract syntax of the entities language. Entities
  have attributes which have types and names. \ic{EntityType} extends 
  \ic{Type} and references \ic{Entity}. This adapts entities to types 
  (cf. the Adapter pattern~\cite{GOF95}). Concepts like \ic{EntityType} which
  have exactly one reference are called smart references and are treated specially
  by MPS: the code completion menu shows \emph{the possible targets} of the
  reference directly, instead of first instantiating the reference concept and
  then selecting the target.}
  \vspace{-3mm}
  \label{entities} 
\end{center}
\end{figure}


\noindent Editors in MPS are based on cells. Cells are the smallest unit
relevant for projection. Consequently, defining an editor consists of arranging cells
and defining their content. Different cell types are available to compose editors.
\fig{editordefinition} explains the editor for \ic{Entity}. The editors for the
other concepts are defined similarly.



\begin{figure}[htp]
\begin{center}
  \vspace{-2mm}
  \includegraphics[scale=0.55]{figures/editordefinition.png}
  \caption[labelInTOC]{The editor for \ic{Entity}. The outermost cell is a
  vertical list. In the first line, we use a horizontal list that contains
  the keyword \ic{entity}, the \ic{name} property and an opening
  curly brace. In the second line we use indentation and a vertical arrangements
  of the contents of the \ic{attributes} collection. Finally, the third line
  contains the closing curly brace.}
  \vspace{-4mm}
  \label{editordefinition} 
\end{center}
\end{figure}


\phead{Type System} As we have explained in \sect{HowMPSWorks}, language
developers only have to specify typing rules for language concepts.
MPS' type system engine applies the rules to all applicable program elements,
solves the resulting set of type equations, and if equations run into
contradictions, this is annotated on the offending program element as a type
error. For the \ic{entities} language, we specify two simple typing rules. The
first one specifies that the type of a \ic{Type} (such as \ic{int} or
\ic{string}) is a clone of itself.

\begin{code}
rule typeof_Type for Type as t {
    typeof(t) :==: t.copy;       
}                                      
\end{code}

\noindent The only other typing rule defines the type of the \ic{Attribute} as a
whole to be the type of the attribute's \ic{type} property, defined as
\ic{typeof(attribute) :==: typeof(attribute.type)}. No other typing rules apply
in this simple language. 


\phead{Generator} From \ic{entities} models we generate Java Beans. Since Java
is available in MPS as the BaseLanguage, the generation is actually a
model-to-model transformation: from the \ic{entities} model we generate a Java
model. MPS supports several kinds of transformations. The default case is the
template-based transformation which maps ASTs onto other ASTs, so they are
essentially model-to-model transformations. Alternatively, one can use an
API to manually construct the target tree. Finally, the \ic{textgen} DSL is
available to generate ASCII text (at the end of the transformation chain).
Throughout this paper we use the template-based approach.

MPS templates look like text generation templates known from tools such as
Xpand\footnote{http://www.eclipse.org/modeling/m2t/?project=xpand}, Jet
\footnote{http://www.eclipse.org/modeling/m2t/?project=jet} or StringTemplate
\footnote{http://www.stringtemplate.org/} since they use the CS of the target
language in the template. However, the CS of the target language in the template
is projected like any other program, and the IDE can provide support for the
target language \emph{in the template}. However, this also means that the
\emph{template code itself} must be valid in terms of the target language.

Template-based generators consist of mapping configurations and templates.
Mapping configurations define which elements are processed with which templates.
For the \ic{entities} language, we need a \emph{root mapping rule} and
\emph{reduction rules}. Root mapping rules can be used to create new root nodes
from existing root nodes (so they map fragments to other fragments). In our case
we generate a Java class from an \ic{Entity}. Reduction rules are in-place
transformations. Whenever the engine encounters an instance of the specified
source concept somewhere in a model tree, it removes that source node and
replaces it with the result of the associated template. In our case we reduce
the various types (\ic{int}, \ic{string}, etc.) to their Java counterparts.
\fig{entitiesmc} shows a part of the mapping configuration for the \ic{entities}
language.


\begin{figure}[htp]
\begin{center}
  \includegraphics[width=80mm]{figures/entitiesmc.png}
  \caption[labelInTOC]{The mapping configuration for the \ic{entities} language. The
  root mapping rule for \ic{Entity} specifies that instances of \ic{Entity} should
  be transformed with the \ic{map\_Entity} template (which produces a Java
  class and is shown in \fig{entitytemplate}). The reduction rules use inline
  templates, i.e. the template is embedded in the mapping configuration. For example, the 
  \ic{IntType} is replaced with the Java \ic{int} and the \ic{EntityRefType} is
  reduced to a reference to the class generated from the target entity. The
  \ic{->\$} is a so-called reference macro. It contains code (not
  shown) that "rewires" the reference (that points to the 
  \ic{Double} class \emph{in the template code}) to a reference to the class
  generated from the target entity. }
  \vspace{-2mm}
  \label{entitiesmc} 
\end{center}
\end{figure}




\fig{entitytemplate} shows the \ic{map\_Entity} template. It generates a complete 
Java class from an input \ic{Entity}. To understand how templates work in MPS we
discuss in more detail the generation of Java fields for each \ic{Entity}
\ic{Attribute}:

\begin{itemize}
  \item Developers first write structurally correct example code in the
  target language. To generate a field into a class for each
  \ic{Attribute} of an \ic{Entity}, one would first add a field to a
  class (see \ic{aField;} in \fig{entitytemplate}).
 
  \item Then macros are attached to
  those program elements is the example code that have to be replaced with
  elements from the input model as the transformation executes.
  In the \ic{Attribute} example in \fig{entitytemplate} we first
  attach a \ic{LOOP} macro to the whole field. It contains an expression
  \ic{node.attributes;} where \ic{node} refers to the input \ic{Entity} (this
  code is entered in the Inspector window and is not shown in the screenshot).
  This expression returns the set of \ic{Attribute}s from the current
  \ic{Entity}, making the \ic{LOOP} iterate over all attributes of the
  entity and create a field for each of them. 
  
  \item At this point, each created field would be \emph{identical} to the
  example code to which we attached the \ic{LOOP} macro (\ic{private int
  aField;}). To make the generated field specific to the particular
  \ic{Attribute} we iterate over, we use more macros. A \ic{COPY\_SRC} macro is
  used to transform the \ic{type}. \ic{COPY\_SRC} copies the input node (the
  inspector specifies the current attribute's \ic{type} as the input here) and
  applies reduction rules (those defined in \fig{entitiesmc}) to map types from
  the \ic{entities} language to Java types. We then use a property macro (the
  \ic{\$} sign around \ic{aField}) to change the \ic{name} property of the field
  we generate to the name of the attribute we currently transform.
  
\end{itemize}

\noindent Instead of mixing template code and target language code (and
separating them with some kind of escape character) we annotate macros to
regular, valid target language code. Macros can be attached to
arbitrary program elements. This way, the target language code in templates
\emph{is always structurally correct}, but it can still be annotated to control
the transformation. Annotations are a generic MPS mechanism not specific to
transformation macros and are discussed in \sect{annotations}.



\begin{figure}[htp]
\begin{center}
  \includegraphics[width=100mm]{figures/entitytemplate.png}
  \caption[labelInTOC]{The template for creating a Java class from an
  \ic{Entity}. The generated class contains a field, a getter and a setter for
  each of the \ic{Attribute}s of the \ic{Entity}. The running text explains the
  details.}
  \label{entitytemplate} 
\end{center}
\end{figure}


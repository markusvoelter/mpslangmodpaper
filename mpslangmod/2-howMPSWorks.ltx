
\section{How MPS works}
\label{HowMPSWorks}

\subsection{Projectional Editing}

The term Language Workbench was coined by Martin Fowler in 2005
\cite{Fowler2004}. In his article he defines a language workbench as a tool with
the following characteristics:

\begin{enumerate}   
  \item Users can freely define languages which are fully integrated with
  each other.

  \item The primary source of information is a persistent abstract
  representation.

  \item A DSL is defined in three main parts: schema, editor(s), and
  generator(s).

  \item Language users manipulate a DSL through a projectional editor.

  \item A language workbench can persist incomplete or contradictory
  information.

\end{enumerate}
	
Note how points 2, 3 and 4 imply projectional editing. In the meantime the community uses the term language workbench also for
tools that use (modern) parsing techniques. MPS is a projectional editor. The
most important characteristic of projectional editors is that all text,
symbols, and graphics are projected. Projectional editing is well-known from
graphical modeling tools (UML, ER, State Charts). The model is stored
independent of its concrete syntax, only the model structure is persisted, often
using XML or a database. For editing purposes this abstract syntax is projected
using graphical shapes. Users use mouse gestures and keyboard actions tailored
to graphical editing to modify the abstract model structure directly. While the
concrete syntax of the model does not have to be stored because it is specified
as part of the language definition and hence known by the projection engine,
graphical modeling tools usually also store information about the visual layout.


Projectional editing can also be used for textual syntax. However, since the
projection looks like text, users expect interaction patterns and gestures known
from "real text" to work. For a projectional editor to be useful, it has to
"simulate" interaction patterns known from real text. MPS achieves this quite
well. How it does that is beyond the scope of this paper. The following is a
list of benefits of the projectional editing approach:

\begin{itemize}   
  \item No grammar or parser is required. Editing directly changes the
  underlying structure. Projectional editors can handle unparseable code.
  Language composition is made easy, because it cannot
  result in ambiguous grammars [1].

  \item Notations are more flexible than ASCII/ANSI/Unicode. Graphical,
  semi-graphical and textual notations can be mixed and combined. For example, a
  graphical tool for editing state machines can embed a textual expression
  language for editing the guard conditions on transitions.

  \item Because projectional languages by definition need an IDE for editing (it
  has to do the projection!), language definition and extension always implies
  IDE definition and extension. The IDE will provide code completion, error
  checking and syntax highlighting for all languages, even when they are
  composed.

  \item Because the model is stored independent of its concrete notation, it is
  possible to represent the same model in different ways simply by providing
  several projections. Different viewpoints of the overall program can be
  stored in one model, but editing can still be viewpoint-specific. It is also
  possible to store out-of-band data (i.e. annotations on the core
  model/program. Examples of this include documentation, pointers to
  requirements (traceability) or feature dependencies in the context of
  product lines.

\end{itemize}

As a side effect, language workbenches deliver on the promise of removing the
difference between what is traditionally considered programming and what is
traditionally considered modeling. This distinction is arbitrary anyway: as
software developers we want to express different concerns of software systems with
abstractions and notations suitable to that particular concern (graphical,
textual, symbolic), formally enough for automatic processing or translation, and
with good IDE support. Projectional language workbenches deliver on this goal.


\subsection{JetBrains MPS}

The JetBrains Meta Programming System is an open source projectional language
workbench. All the statements on projectional editing made earlier apply to MPS.
Defining a language includes (a) defining the language concepts (abstract
syntax), (b) defining the editor for the concepts, and (c) defining a generator
(compiler). For a language whose programs should be processed with text-oriented
tools (such as existing compilers or interpreters) the generator outputs text.
For higher-level languages, assimilation is used as a means of integrating the
semantics of the extended language with the base language: the generator
transforms a program expressed in $L_D$ (a language for the domain $D$, see
\cite{VoelterVisserVoelterVisserVoelterVisser2011} for details on hierarchical
domains and languages, and the $L_D$ notation) into a program at $L_{D-1}$ (a
program at a lower domain). In this case, the generators are not text
generators, they transform between abstract syntax trees (this process is
explained in more detail below).


Editing the tree as opposed to "real text" needs some time to get used to.
Without specific customization, every program element has to be selected from a
drop-down list to be "instantiated". However, MPS provides editor customizations
to enable editing that resembles modern IDEs that use automatically expanding
code templates. This makes editing quite convenient and productive in all but
the most exceptional cases. We will show in Section \ref{entitiesLanguage} how
to actually build a language with MPS.





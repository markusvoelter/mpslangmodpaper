
\section{How MPS works}
\label{HowMPSWorks}

The JetBrains Meta Programming System \todo{ref} is a projectional language
workbench available as Open Source software under the Apache 2.0
license. The term Language Workbench was coined by Martin Fowler in
2005 \cite{Fowler2004}. In his article he defines a language workbench as a tool
with the following characteristics:

\begin{enumerate}   
  \item Users can freely define languages which are fully integrated with
  each other.

  \item The primary source of information is a persistent abstract
  representation.

  \item A DSL is defined in three main parts: schema, editor(s), and
  generator(s).

  \item Language users manipulate a DSL through a projectional editor.

  \item A language workbench can persist incomplete or contradictory
  information.

\end{enumerate}

MPS exhibits all of these characteristics. MPS' most distinguishing feature is
its projectional editor. This means that all text,
symbols, and graphics are projected, and not parsed. Projectional editing is
well-known from graphical modeling tools (UML, ER, State Charts). The model is stored
independent of its concrete syntax, only the model structure is persisted, often
using XML or a database. For editing purposes, graphical editors project the
abstract syntax using graphical shapes. Users use mouse gestures and keyboard actions tailored
to graphical editing to modify the abstract model structure directly. While the
concrete syntax of the model does not have to be stored because it is specified
as part of the language definition and hence known by the projection engine,
graphical modeling tools usually also store information about the visual layout.

Projectional editing can also be used for textual syntax. However, since the
projection looks like text, users expect editing gestures known
from "real text" to work. For a projectional editor to be useful, it has to
"simulate" interaction patterns known from real text. MPS achieves this quite
well. How it does that is beyond the scope of this paper. The following is a
list of benefits of the projectional editing approach:

\begin{itemize}   
  \item No grammar or parser is required. Editing directly changes the
  underlying structure. Projectional editors can handle unparseable code.
  Language composition is made easy, because it cannot
  result in ambiguous grammars [1].

  \item Notations are more flexible than ASCII/ANSI/Unicode. Graphical,
  semi-graphical and textual notations can be mixed and combined. For example, a
  graphical tool for editing state machines can embed a textual expression
  language for editing the guard conditions on
  transitions\footnote{Intentional's Domain Workbench has demonstrated this
  repeatedly, for example in \todo{OOPSLA Paper}. As of 2012, MPS can do text,
  symbols (such as big sum signs or fraction bars) and tables. Graphics will be
  supported in 2013.}.

  \item Because projectional languages by definition need an IDE for editing (it
  has to do the projection!), language definition and extension always implies
  IDE definition and extension. The IDE will provide code completion, error
  checking and syntax highlighting for all languages, even when they are
  composed.

  \item Because the model is stored independent of its concrete notation, it is
  possible to represent the same model in different ways simply by providing
  several projections. Different viewpoints of the overall program can be
  stored in one model, but editing can still be viewpoint-specific. It is also
  possible to store out-of-band data (i.e. annotations on the core
  model/program. Examples of this include documentation, pointers to
  requirements (traceability) or feature dependencies in the context of
  product lines.

\end{itemize}

Projectional editors also have drawbacks. The first one is that editing the tree
as opposed to "real text" needs some time to get used to. Without specific
customization, every program element has to be selected from a drop-down list to
be "instantiated". However, MPS provides editor customizations to enable editing
that resembles modern IDEs that use automatically expanding code templates. This
makes editing quite convenient and productive in all but the most exceptional
cases. The second drawback is that models are not stored as readable text, but
rather as a serialized abstract syntax tree (typically XML). Integrating XML
files with an otherwise ASCII-based development infrastructure can be a
challenge. MPS addresses the most critical aspect of this drawback: it supports
diff and merge on the level of the projected concrete syntax. \todo{Add the
drawback of the closedness of MPS.}


MPS has been designed from the start
to work with sets of integrated languages. This makes MPS particularly well
suited to demonstrate \lmrc\ techniques. In particular, the following three
characteristics are important in this context:

\begin{description}
\item[Composable Syntax:] Depending on the particular composition approach used,
syntactic composition of the languages is required. In traditional, grammar-based systems, combining
independently developed grammars can be a problem: many grammar classes are not
closed under composition, and various invasive changes (such as left-factoring
or redefinition of terminals or non-terminals), or unwanted syntactic escape
symbols are required \todo{ref}. As we will see, this is not the case in MPS.
Arbitrary languages can be combined syntactically.

\item[Extensible Type Systems:] All of the composition techniques require some
degree of type system extension or integration. MPS' type system specification is based on decarative type system rules that are
executed by a solver. This way, additional typing rules for additional language
constructs can be defined without invasively changing the existing typing rules
of the composed languages.

\item[Modular Transformation Framework:] Transformations can be defined 
separately for each language concept. If a new language concept is added via a
composition technique, the transformation for this new concept is modular. If
existing transformation should be overridden or a certain program structure must
be treated specially, a separate transformation for these cases can be written,
and, using generator priorities, it can be made sure that it runs \emph{before}
an existing transformation. This way, existing transformations can be enhanced
or overridden in a modular way.

\end{description}

\noindent The MPS-based examples for the language composition techniques
discussed in this paper will elaborate on these characteristics. This is why for each technique,
we discuss structure and syntax, type system and transformation concerns.  






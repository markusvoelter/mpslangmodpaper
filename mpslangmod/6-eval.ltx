
\section{Evaluation}
\label{Eval}

The examples above show that meaningful LME\&C is possible with MPS.
Specifically, reuse and embedding of languages is possible. The challenge
of grammar composition is not an issue in MPS at all, since no grammars and
parsers are used. The fact that we hardly ever discuss syntactic issues in the
above discussions is proof of this. 

However, extensibility regarding the other aspects is a bit less well
structured:

\begin{itemize}
  \item In case of generators, language designers have to specify a partial
  ordering of mapping configurations using priorities. It is not easily possible
  to "override" an existing generator, but generators can run \emph{before}
  existing ones. Generator extension is not possible directly, this is why we
  use the placeholders that are put in by earlier generators to be reduced by
  later ones.
  \item The concrete syntax for elements of the base language cannot be
  overridden in the sublanguage, although this is supposed to change.
  \item Overriding of scopes is not possible; a workaround exists by factoring
  the code into a virtual method (and calling it from the scope).
  \item Typing rules cannot be overridden unless an overloaded operation rules
  container is used in the original language.
\end{itemize}

In my opinion, a consistent approach for extending and overriding aspects of the
original language is missing. I suggest an approach called \emph{Generic
Outside, Specific Inside}. It is basically a variant of component-based design
(\verb+http://en.wikipedia.org/wiki/CBD+). All
language aspects use components as the core structural building block.
Components have types. The type of the component determines the kinds of facets
it has. A facet is a kind of interface that exposes the (externally visible)
ingredients of the component. The kinds of ingredients depend on the component
type: a component of type \emph{structure} exposes language concepts. A
component of type \emph{editor} exposes editors, type \emph{type system} exposes
type system rules, and so on. Each component type would use a different DSL for
implementation. Here is the important point: a component (in a sublanguage) can
specify an \emph{advises} relationship to another component (from a super
language). Then each of the facets can determine which facets from the advised
component it wants to \emph{preempt}, \emph{enhance} or \emph{override}.
\fig{gosi} shows the meta model of the approach.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.45]{figures/gosi.png}
  \caption[labelInTOC]{Components contain facets. Facets come in different
  kinds and the component type determines which facets types are available. The
  facets export the component's contribution to a language. Facets can
  declare relations to other facets (preempt, enhance, override) as a generic
  way to change the contributions exported by components of a base language.}
  \label{gosi}  
\end{center}
\end{figure}

This approach would provide the same way of packaging behavior for all language
aspects, as well as a single, consistent way of changing that behavior in a
sublanguage:

\begin{itemize}
  \item \emph{preemption} means that the respective behavior is contributed
  before the the behavior from the base language. A generator may use this to reduce a
  construct before the original generator gets a chance to reduce the construct. 
  \item \emph{enhancement} means that the sublanguage component is executed
  after the advised component from the base language. Notice that for declarative aspects
  where ordering is irrelevant, preempt and enhance are exchangable.
  \item \emph{overriding} means that the original facet is completely
  shadowed by the new one. This could be used for example to define a new editor for an existing
  construct.
\end{itemize}

To control the granularity at which preemption, enhancement or overriding is
performed, the base language designed would have to group his structures or
behaviors into suitably cut facets. This amount of preplanning is acceptable: it
is just as in OO programming, where behavior that should be overridable has to
be packaged into its own method.
  
The approach could be taken further. Components could be marked as
\emph{abstract}, and define a set of parameters for which values need to be
provided by non-abstract subcomponents. A language is abstract as long as it has
at least one abstract component, for which no concrete subcomponent is provided.
Component parameters could even be usable in structure definitions, for example
as the base concept; this would make a language parametrizable regarding the
base language it extends from.

In essence, the suggested approach is a bit like object orientation (components
== classes, facets == methods), with a rich advise framework (as in AOP).
Component parameters typed to language concepts are similar to generics. Using
this approach, a powerful and consistent approach to language extensibility
would be available.
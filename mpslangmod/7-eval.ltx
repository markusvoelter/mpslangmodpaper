
\section{Discussion}
\label{Eval}

\todo{Discuss which aspects (debuggers, profilers, etc) are still missing in
the composition story.}

The previous examples show that meaningful \lmrc is possible with MPS.
Specifically, reuse and embedding of languages is possible. The challenge
of grammar composition is not an issue in MPS, since no grammars and
parsers are used. The fact that we hardly ever discuss syntactic issues in the
above discussions is proof of this. 

However, extensibility regarding the other aspects is a bit less well
structured:

\begin{itemize}
  \item In the case of generators, language designers have to specify a partial
  ordering of mapping configurations using priorities. It is not easily possible
  to "override" an existing generator, but generators can run \emph{before}
  existing ones. Generator extension is not possible directly. This is why we
  use the placeholders that are put in by earlier generators to be reduced by
  later ones.
  \item The concrete syntax for elements of the base language cannot be
  overridden in the sublanguage, although this is supposed to change.
  \todo{Reviewer says that this has worked in LISA 10 years ago. Check!}
  \item Overriding of scopes is not possible; a workaround exists by factoring
  the code into a virtual method (and calling it from the scope).
  \item Typing rules cannot be overridden unless an overloaded operation rules
  container is used in the original language.
\end{itemize}

In my opinion, a consistent approach for extending and overriding aspects of the
original language is missing. I suggest an approach called \emph{Generic
Outside, Specific Inside}. It is basically a variant of component-based design
(\ic{http://en.wikipedia.org/wiki/CBD}). All
language aspects use components as the core structural building block.
Components have types. The type of the component determines the kinds of facets
it has. A facet is a kind of interface that exposes the (externally visible)
ingredients of the component. The kinds of ingredients depend on the component
type: a component of type \emph{structure} exposes language concepts. A
component of type \emph{editor} exposes editors, type \emph{type system} exposes
type system rules, and so on. Each component type would use a different DSL for
implementation. Here is the important point: a component (in a sublanguage) can
specify an \emph{advises} relationship to another component (from a super
language). Then each of the facets can determine which facets from the advised
component it wants to \emph{preempt}, \emph{enhance} or \emph{override}.
\fig{gosi} shows the meta model of the approach.


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.45]{figures/gosi.png}
  \caption[labelInTOC]{Components contain facets. Facets come in different
  kinds and the component type determines which facet types are available. The
  facets export the component's contribution to a language. Facets can
  declare relations to other facets (preempt, enhance, override) as a generic
  way to change the contributions exported by components of a base language.}
  \label{gosi}  
\end{center}
\end{figure}

This approach would provide the same way of packaging behavior for all language
aspects, as well as a single, consistent way of changing that behavior in a
sublanguage:

\begin{itemize}
  \item \emph{preemption} means that the respective behavior is contributed
  before the behavior from the base language. A generator may use this to reduce a
  construct before the original generator gets a chance to reduce the construct. 
  \item \emph{enhancement} means that the sublanguage component is executed
  after the advised component from the base language. Notice that for declarative aspects
  where ordering is irrelevant, preempt and enhance are exchangable.
  \item \emph{overriding} means that the original facet is completely
  shadowed by the new one. For example, this could be used to
  define a new editor for an existing construct.
\end{itemize}

To control the granularity at which preemption, enhancement or overriding is
performed, the base language designer would have to group the structures or
behaviors into suitably cut facets. This amount of preplanning is acceptable: it
is just as in OO programming, where behavior that should be overridable has to
be packaged into its own method.
  
The approach could be taken further. Components could be marked as
\emph{abstract}, and define a set of parameters for which values need to be
provided by non-abstract subcomponents. A language is abstract as long as it has
at least one abstract component, for which no concrete subcomponent is provided.
Component parameters could even be usable in structure definitions, for example
as the base concept; this would make a language parametrizable regarding the
base language it extends from.

In essence, the suggested approach is a bit like object orientation (components
== classes, facets == methods), with a rich advice framework (as in AOP).
Component parameters typed to language concepts are similar to generics. Using
this approach, a powerful and consistent approach to language extensibility
would be available.


\subsection{Real-World use of MPS}

\paragraph{Web Development} JetBrains' YouTrack issue tracking system is an
interactive web application with many UI features known from desktop
applications. YouTrack is the first JetBrains product that was developed
completely with MPS. The effort for building the necessary MPS-based languages
will be repaid by future applications that build on the same web platform
architecture and hence use the same set of languages. Language extension is used
to add product-specifics to these languages.

\todo{refer to WebDSL}

Web development involves many languages. In the browser, HTML, CSS, JavaScript
and SVG are used. All of these languages embed one another. On the Java-based
server side, a set of descriptive languages is used, together with query
languages (EQL, HBQL, SQL), template languages (JSP, Velocity) and of course the
Java programming language at the core. JetBrains decided to wrap these
platform-specific implementation languages with a set of Java language
extensions. For the sake of the example, we focus on describing the extensions
used in the Java-based backend. The most notable of the languages used in
YouTrack are \emph{dnq} and \emph{webr}. \emph{dnq} is a Java language extension
for working with persistent data and queries. Almost all modern web applications
store data in a database. However, database manipulation is not very well
supported in general-purpose languages such as Java. Developers use object
relational mapping frameworks such as Hibernate, JDO or JPA to alleviate this
problem. These frameworks basically map database rows to Java classes. However,
because authors of these frameworks cannot change the Java language, the
integration is limited, hampering developer productivity \todo{provide a
reference for the ``hampering'' claim}. For example:


\begin{itemize}   
  \item Entity relations which are inherently bidirectional
cannot be easily expressed in Java. Consider a program which models
organizational structure, consisting of Departments and Employees. When an
Employee is added to a Department, both, the references in Employee and
Department must be updated consistently.
  \item Relational databases optimize queries very aggressively. In order to accomplish these optimizations,
queries should be expressed in SQL. However, it is much more natural to use the
programming language for querying a database, especially if the query language
were integrated with the host language and its type system. To enable this, the
programming language must be extended with query constructs and these must be
translated into SQL when the program is compiled.
\end{itemize}



 The \emph{dnq} language supports the
expression of relations in a more natural way: unidirectional and bidirectional
relationships can be declared, distinguishing between composition and
references. Programmers can access them in a way similar to accessing fields in
Java. \emph{dnq} also includes a collections language which supports
the manipulation of collections in a way similar to .NET's LINQ. For example,
\emph{dnq} supports code such as the following:



\begin{code}
aColl.where({it=> it.val < 20 && it.val > 10}).select({it=> it*it});
\end{code}

This code is more declarative than procedural collection manipulation code
which allows MPS to optimize such queries to the database. 

The \emph{webr} language is used for request handling in web applications. In
web frameworks this task is typically accomplished by controller classes and
HTML templates. To configure HTTP request handling, frameworks often use XML
based descriptors. In order to process the HTML templates, template engines are
used. Examples include JSP, Velocity or FreeMarker.  \emph{webr} supports this
through Java language extension. Its template language combines XML and Java,
relatively similar to JSP at first glance. However, based on MPS' ability to
extend languages, \emph{webr} provides much more freedom of what templates can
contain. For example, in many template engines, it is impossible to add new
constructs to the template language. In JSP it is possible using extension tags
but the XML-based syntax is quite verbose. In \emph{webr} templates, developers
can choose whatever syntax they like by defining a suitable language extension.
An example used in YouTrack is a UI components language that is not limited to
XML syntax. \emph{webr} also provides first-class support for controllers. For
example, controllers can declare actions and attach them directly to events of
UI components. Parameters are specified in special entities called template
controllers. \emph{webr} is well-integrated with \emph{dnq}, so for example, it
is possible to use a persistent entity as a parameter to a page. The database
transaction is automatically managed during request processing. 

\todo{generally: more references for ``stuff'' and not just related work}
  
\paragraph{Embedded Development} Embedded systems are becoming more 
software intensive and the software becomes bigger and more complex. Traditional
embedded system development approaches use a variety of tools for various
aspects of the system, making tool integration a major challenge. Some of the
specific problems of embedded software development include the limited
capability for meaningful abstraction in C, some of C's "dangerous" features
(leading to various coding conventions such as Misra-C \todo{ref}), the
proprietary and closed nature of modeling tools, the integration of models and code,
traceability to requirements, long build times as well as management of product
line variability. To address these issues, we propose an alternative approach
based on the incremental extension of C. We have implemented a proof-of-concept
language (\ic{http://mbeddr.com}) that contains a set of language extensions
relevant to this embedded development. A larger-scale research project is
starting in July 2011 to continue the development of this approach.
 
For the proof-of-concept, the mbeddr project uses Lego Mindstorms \todo{ref} as
the target platform together with the OSEK operating system \todo{ref} to ensure
real-world relevance. The current showcase is a line follower robot. It uses a single light sensor to
follow (one side of) a thick black line by changing the speed of motors that
drive the two wheels. The current state of the prototype contains language
modules for components, tasks, state machines, bit-level data structures,
physical quantities, documentation annotations, as well as core module with
basically all of C. There is a clearly defined dependency structure between
those languages, with the core language at the root. We have also added a DSL
for simplified control of the two-wheeled robot using commands such as
accelerate, turn left, or stop. The implementation of this DSL is a model
transformation down to the basic embedded languages: we generate tasks,
procedures and state machines, which are then (automatically) transformed down
to actual C and are compiled by GCC for the OSEK target.
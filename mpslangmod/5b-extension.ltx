
\subsection{Language Extension}

\begin{figure}[t]
\begin{center}
  \includegraphics[width=8.2cm]{figures/langExtension.png} 
  \caption[labelInTOC]{Extension: $l_2$ extends $l_1$. It provides additional
  concepts $B3$ and $B4$. $B3$ extends $A3$, so it can be used as a child of
  $A2$, plugging $l_2$ into the context provided by $l_1$. Consequently,
  $l_2$ depends on $l_2$.}
  \label{langExtension}  
\end{center}  
\end{figure}

Language extension  enables \emph{heterogeneous} fragments
with \emph{dependent} languages (\fig{langExtension}). A language $l_2$
extending $l_1$ adds additional language concepts to those of $l_1$. We call $l_2$ the
\emph{extending} language, and $l_1$ the \emph{base} language. To allow the new
concepts to be used in the context provided by $l_1$, some of them extend
concepts in $l_1$. So, while $l_1$ remains independent, $l_2$ becomes dependent
on $l_1$ since some of the concepts in $l_2$ will inherit from concepts in
$l_1$:
\begin{align}
\exists i \in \mathit{Inh(l_2)} \mid \mathit{i.sub} = l_2\; \wedge \; 
	\mathit{i.super} = l_1
\end{align}
Consequently, a fragment $f$ contains language concepts from both $l_1$ and
$l_2$:
\begin{align}
\forall e \in E_f \mid \mathit{lo(e)} = l_1 \vee \mathit{lo(e)} = l_2
\end{align}  
In other words, $C_f \subseteq (C_{l_1} \cup C_{l_2})$, so $f$ is
\emph{heterogeneous}. For heterogeneous fragments (3) does not
hold anymore, since
\begin{align}  
\forall c \in \mathit{Cdn_f} \mid\; 
   &(\mathit{lo(co(c.parent))} = l_1 \vee \mathit{lo(co(c.parent))} = l_2 )
   \; \wedge \; \nonumber \\ 
   &(\mathit{lo(co(c.child))} = l_1 \vee \mathit{lo(co(c.child))} = l_2 )
\end{align} 
Note that copying a Language definition and changing it does not constitute a
case of language extension, because the extension is not modular, it is
invasive. Also, a native interfaces that supports calling one language from
another, like calling C from Perl or Java, is not language extension;
rather it is a form of language referencing. The fragments remain homogeneous.



As an example, we extend the MPS base language with block expressions
and placeholders. These concepts make writing generators \emph{that generate
base language code} much simpler. \fig{expressionBlock} shows an example. We use
a screenshot instead of text because we use non-textual notations (the big
brackets) and color. 


\phead{Structure and Syntax} A block expression is a block that can be used
where an \ct{Expression} is expected \cite{BravenboerVVV05}. The block can
contain any number of statements; \ct{yield} can be used to "return values" from
within the block. So, in some sense, a block expression is an "inlined
method", or a closure that is defined and called directly. The optional name property of
a block expression is then used as the method name. The generator of the
block expression transforms it into just this structure:


\begin{code}
okButton.addActionListener(new ActionListener() {
  public void actionPerformed(ActionEvent p0) {
    Employee aEmployee = new Employee();
    aEmployee.setName(retrieve_name(aEmployee, widget0));
  }
  public String retrieve_name(Employee aEmployee, JComponent widget0) {
    String newValue = ((JTextField) widget0).getText();
    return newValue;
  }
}
\end{code}

\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.6]{figures/expressionBlock.png}
  \caption[labelInTOC]{Block Expressions (rendered with a shaded background) are
  basically anonymous inline methods. Upon transformation, an actual method is
  generated that contains the block content, and the block expression is replaced with a call to this
  generated method. Block expression are used mostly when implementing
  generators; this screenshot shows a generator that uses a block expression.}
  \label{expressionBlock} 
\end{center}
\end{figure}

The \ic{jetbrains.mps.baselanguage.exprblocks} language extends MPS' BaseLanguage.
The block expression is used in places where the base language
expects an \ct{Expression}. This is why a \ct{BlockExpression} extends
\ct{Expression}. Consequently, fragments that use the \ic{exprblocks} language, can
now use \ct{BlockExpression}s in addition to the concepts provided by the base
language. The fragments become \emph{heterogeneous}, because the languages are
mixed.

\begin{code}
concept BlockExpression extends Expression implements INamedConcept
  children:                                     
    StatementList body 1      
\end{code}
          
\phead{Type System} The type of the \ct{yield} statement is the type of the
expression that is \ic{yield}ed, specified by 
\ic{typeof(yield) :==: typeof(yield.result);} (so the type of \ic{yield 1;}
 would be \ct{int}, because the type of \ic{1} is \ic{int}). Since the
 \ct{BlockExpression} is used as an expression, it has to have a type as well. Since it is not explicitly specified, the type of
the \ct{BlockExpression} is the common super type of the types of all the
yields. The following typing rule computes this type:

\begin{code}
var resultType ; 
for (node<BlockExpressionYield> y : 
        blockExpr.descendants<concept = BlockExpressionYield>) { 
  resultType :==: typeof(y.result); 
} 
typeof(blockExpr) :==: resultType;
\end{code}
          
          
\phead{Generator} The generator for \ct{BlockExpression}s reduces the new 
concept to pure base
language: it performs assimilation. It transforms a heterogeneous fragment
(using BaseLanguage and \ic{exprblocks}) to a homogeneous fragment (using only
BaseLanguage). The first step is the creation of the additional method 
for the block expression (\fig{expressionBlockGenerator1}).



% > 5.2 #Generator (Pg 12): AFAIK we have "extract method" instruction in
% > code generator. This was designed exactly for use case you are trying
% > to cover using weavings.



\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.5]{figures/expressionBlockGenerator1.png}
  \caption[labelInTOC]{We use a weaving rule to create an additional method for
  a block expression. A weaving rule processes an input element
  (\ct{BlockExpression}) by creating another node in a different place. The context function defines this
  other place. In this example, it simply gets the class in which we have
  defined the particular block expression, so the additional method is generated
  into that class.}
  \label{expressionBlockGenerator1} 
\end{center}
\end{figure}
 

The template shown in \fig{expressionBlockGenerator2} shows the creation of the
method. It assigns a mapping label to the created method. The mapping label
creates a mapping between the \ct{BlockExpression} and the created method. We
will use this label to refer to this generated method when we generate the
method call that replaces the \ct{BlockExpression}
(\fig{expressionBlockGenerator3}).


\begin{figure}[htp] 
\begin{center}
  \includegraphics[scale=0.5]{figures/expressionBlockGenerator2.png}
  \caption[labelInTOC]{This generator template creates a method from the block
  expression. It uses \ic{COPY\_SRC} macros to replace the dummy \ct{string}
  type with the computed return type of the block expression, inserts a computed name, adds a
  parameter for each referenced variable outside the block, and inserts all the
  statements from the block expression into the body of the method. The
  \ct{blockExprToMethod} mapping label is used later when generating the call to
  this generated method (shown in \fig{expressionBlockGenerator3}).}
  \label{expressionBlockGenerator2} 
\end{center}
\end{figure}


\begin{figure}[htp]
\begin{center}
  \includegraphics[scale=0.5]{figures/expressionBlockGenerator3.png}
  \caption[labelInTOC]{Here we generate the call to the previously generated
  method. We use the mapping label \ct{blockExprToMethod} to refer to the
  correct method (not shown; happens inside the reference macro). We pass in
  the environment variables as actual arguments using the \ic{LOOP} and
  \ic{COPY\_SRC} macros.}
  \label{expressionBlockGenerator3} 
\end{center}
\end{figure}

A second concept introduced by the \ic{exprblocks} language is the
\ct{PlaceholderStatement}. It extends \ct{Statement} so it can be used
inside method bodies. It is used to mark locations at which subsequent
generators want to add additional code. These subsequent generators will use a
reduction rule to replace the placeholder with whatever they want to put at this
location. It is a means to building extensible generators, as we will see later.


In the classification section \todoref{} we mentioned that we consider
restriction as a form of extension. To illustrate this point we restrict the
block expression regarding the children it may have: we prevent the use of
\ic{return} statements inside block expressions (the reason for this restriction
is that the way we generate from the block expressions cannot handle return
statements). To achieve this, we add a \ic{can be ancestor} constraint to the
\ic{BlockExpression}:

\begin{code} 
concept constraints for BlockExpression {

  can be ancestor:
    (operationContext, scope, node, childConcept, link)->boolean { 
      childConcept != concept/ReturnStatement/;  
    }
	  
}
\end{code}

The \ic{childConcept} variable represents the concept of which an instance is
about to be added under a \ic{BloclExpression}. The constraint expression has to
return \ic{true} if the respective \ic{childConcept} is valid in this location.
We make sure the \ic{childConcept} is not a \ic{ReturnStatement}. Note how this
constraint is written \emph{from the perspective of the ancestor} (the
\ic{BlockExpression}). MPS also supports writing constraints from the
perspective from the child. This is important to keep dependencies pointing in
the right direction.


Extension comes in two flavors. One really feels like extension, and the other
one feels more like embedding. We have described the one that feels like
extension in this section: we provide (a little, local) additional syntax to an
otherwise unchanged language (block expressions and placeholders). The programs
still essentially look like Java programs, and in a few particular places,
something is different. Extension with embedding flavor is where we create a
completely new language, but reuse some of the syntax provided by a base
language. For example, we could create a state machine language that reuses
Java's expression and types in guard conditions. This use case \emph{feels} like
embedding (we embed syntax from the base language in our new language), but in
the classification according to syntactic integration and dependencies, it is
still extension. Embedding would prevent a dependency between the state machine
language and Java.
  
  
